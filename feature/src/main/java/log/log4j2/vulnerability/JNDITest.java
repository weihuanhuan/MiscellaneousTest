package log.log4j2.vulnerability;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class JNDITest {

    public static void main(String[] args) {

        Logger logger = LogManager.getLogger("ROOT");

//        logger.info("${jndi://attack}");

        logger.info("test {} logging", "${jndi://attack}");

        /*
        openrasp 处理 jndi 注入的潜在 hook 点。
        is_hostname_dnslog
            检测 CheckParameter.Type#SSRF 场景 hook 点
                com.baidu.openrasp.hook.SocketHook#isClassMatched
                AbstractClassHook (com.baidu.openrasp.hook)
                    AbstractSSRFHook (com.baidu.openrasp.hook.ssrf)
                        CommonHttpClientHook (com.baidu.openrasp.hook.ssrf)
                        WeblogicUDDIHook (com.baidu.openrasp.hook.ssrf)
                        HttpClientHook (com.baidu.openrasp.hook.ssrf)
                        OkHttpHook (com.baidu.openrasp.hook.ssrf)
                        URLConnectionHook (com.baidu.openrasp.hook.ssrf)
        validate_stack_java
            检测 CheckParameter.Type#COMMAND 场景 hook 点
                com.baidu.openrasp.hook.system.ProcessBuilderHook#isClassMatched
            检测 CheckParameter.Type#DIRECTORY 场景 hook 点
                com.baidu.openrasp.hook.file.FileHook#isClassMatched
                com.baidu.openrasp.hook.file.NioFilesListHook#isClassMatched
            检测 CheckParameter.Type#WRITEFILE 场景 hook 点
                com.baidu.openrasp.hook.file.FileOutputStreamHook#isClassMatched
                com.baidu.openrasp.hook.file.NioFilesWriteHook#isClassMatched
        */

        /*
        openrasp js 中对 log4j2 jndi 注入漏洞的检测能力，发现有俩个函数可以处理。

        1.is_hostname_dnslog，通过检测 Socket 调用 connect 时的主机地址来实现，
            检测 SSRF 场景 hook 点，这个只能处理 jndi 中需要访问远程服务器的形式
        这个现在就能直接用，局限于有远程访问时才能检测。

        2.validate_stack_java，这个可以检测调用栈中的方法调用关系，
            检测 COMMAND 场景 hook 点，这个只能在 java 调用其他进程时进行检测
            检测 DIRECTORY 场景 hook 点，这个只能在list文件时进行检测
            检测 WRITEFILE 场景 hook 点，这个只能在写入文件时进行检测
        这个需要添加一个针对 jndi 的 hook 点才行，然后在调用栈中查询是否有 log4j2 的 jndi 解析栈就可以了。

        第二个方法也有个问题就是怎么区分是用户自己日志中确实需要的 jndi 查询，还是被注入的jndi查询。
        这个应该只能通过jndi hook点使用的 jndi 名字来判断了。
        */
    }

}
